{"componentChunkName":"component---src-templates-tag-tsx","path":"/tags/javascript/","webpackCompilationHash":"ff82b448ff05a0cfe069","result":{"data":{"site":{"siteMetadata":{"title":"Jeff Rafter"}},"allMarkdownRemark":{"totalCount":3,"edges":[{"node":{"excerpt":"Create a repository on github If you don‚Äôt already have an account on GitHub, create one. For me, my username is\njeffrafter. You can sign up for a free account and still host your\nblog. Note: by default, your username will be part of the URL for your blog. We can change\nthat later. Next, create a new repository and name the repository . For me, I‚Äôve\nnamed mine .  Build and push Once you‚Äôve created the repository you need to add it as an  to your local copy: Again, using GitHub Desktop can simplify pushing code as it manages\nyour login.  Pull requests and branches  Custom domains","fields":{"slug":"/deploying-gatsby-to-github-pages/"},"frontmatter":{"date":"2019-06-01T00:01:00","title":"Deploying Gatsby to GitHub Pages","excerpt":null}}},{"node":{"excerpt":"Our plan is to build a website using Next.js.\nNext.js is built on top of Express. Out of the box, it supports server side rendering, hot module\nreloading, React and more. We‚Äôll add TypeScript, Styled Components, Sessions, Authentication,\nsome basic security and more. Gatsby is client side framework for building static sites. Static sites\nare great for brochure websites, portfolios and blogs. If you are building a site which needs\nserver-side processing (e.g., sites that require authentication or server-to-server interaction such\nas payment processing) then Next.js handles both\nthe client and server side. It‚Äôs important to remember that there are countless ways to accomplish a task within the Node\necosystem. This has a positive side and a negative side. This post represents one set of choices\nI made when I wrote this. Given how quickly things move, if I started over I might not make the\nsame choices and that is okay. In order to follow this, you‚Äôll need access to a terminal (or console) and you‚Äôll need Node, Node Version Manager, and git installed. Getting started First you want to create a folder for your project: We‚Äôll be using Next.js which is a toolkit that is written in TypeScript (a typed variant of JavaScript) and requires Node. If you have multiple local projects you might run into a conflict about which Node version should be used. Node Version Manager solves this problem. To control which version of Node should be used in your project, add an  file: The file is pretty simple; just the version. At the time you read this there may be a newer version of Node. You can check https://nodejs.org.  Ignore some things We plan to use  to keep track of our changes. As we work on our project locally, there will be a lot of files we won‚Äôt want to keep track of; we‚Äôll want to ignore them. To do this we‚Äôll create a new file called  . These files can be very short and specific, or they can be very long and general. We‚Äôll use a more generic one that will work on different kinds of computers. If you are looking for an example  you can check out https://github.com/github/gitignore. For now, just copy the following:  nodemon.json   Optional If you are using VSCode, it is useful to make sure all of the developers have a consistent experience. To do that you can keep a  folder with the default settings: Create the folder: And make    You might not be using VSCode. In that case you might want to opt for the more generic  file (based on the format from https://editorconfig.org):   Because we want to use TypeScript, we‚Äôll need to run the code through Babel on build to create compatible JavaScript. Create a  file:   If you aren‚Äôt using eslint then you are likely using prettier. It is pretty safe to choose one or the other. If you choose prettier add a  file:   In general, eslint will be more powerful than prettier (though often overkill) ‚Äî offering lots of plugins and rules. If you use eslint, add an : Additionally if you‚Äôll want to ignore certain files for performance reasons, add a .   From gatsby: From a next project (server/tsconfig.js:    Configure next with  From the example (): From gist-playground  Testing with  .env\n.env.test","fields":{"slug":"/next-with-typescript/"},"frontmatter":{"date":"2019-04-23T00:01:00","title":"Next.js with TypeScript","excerpt":null}}},{"node":{"excerpt":"Creating a static website involves an almost infinite set of choices. Among these is\nGatsby ‚Äì a static site framework based on , ,  and\nmany other modern approaches. Gatsby is, in many ways, the JavaScript successor to\nJekyll. I‚Äôve upgraded several sites to Gatsby (including this one) finding\na way to integrate TypeScript as part of the journey. Before you read this it is important to point out: you should start with a template. In this post I\nam going to work through all of the steps and try to explain them along the way. Included\nin this post are some of the reasons behind why I‚Äôve chosen one particular plugin or skipped\nanother. Often ‚Äì especially when you choose a default Gatsby starter ‚Äì it is difficult to understand\nhow all of the pieces fit together, or how you might build your own starter template. Hopefully\nthis post provides some helpful examples. Also: the Gatsby documentation is extremely good. There is a\nfantastic tutorial, quick start and some recipes. I‚Äôve relied on those and a host of other blogs when working on this\npost. In order to follow this, you‚Äôll need access to a terminal (or console) and you‚Äôll need Node, Node Version Manager, and git installed. All of the code (and commits) are availble on GitHub: https://github.com/example-gatsby-typescript-blog/example-gatsby-typescript-blog.github.io Getting started First you want to create a folder for your project: We‚Äôll be using Gatsby which is a toolkit that is written in TypeScript and requires Node. If you have multiple local projects you might run into a conflict about which Node version should be used. Node Version Manager solves this problem. To control which version of Node should be used in your project, add an  file: The file is pretty simple; just the version. At the time you read this there may be a newer version of Node. You can check https://nodejs.org.  Ignore some things We plan to use  to keep track of our changes. As we work on our project locally, there will be a lot of files we won‚Äôt want to keep track of; we‚Äôll want to ignore them. To do this we‚Äôll create a new file called  . These files can be very short and specific, or they can be very long and general. We‚Äôll use a more generic one that will work on different kinds of computers. If you are looking for an example  you can check out https://github.com/github/gitignore. For now, just copy the following: Configure your editor This section is completely optional. This is here mostly so I can copy and paste the configuration for myself. üé° If there are several people working on your project, the chances are high that they use different editors for their code. At the very least their settings might not be consistent. You can provide hints to their editors. This can be done by including a generic  file (based on the format from https://editorconfig.org): Depending on the editor this may or may not be used. Not to worry, we‚Äôll add  later which will ensure that the code is consistent. You might be using VSCode. In that case you can add some additional configuration. To do that you can create a  folder with the settings for your project. Create the folder: And in that folder make   Keeping things clean People have different preferences when they edit code. Some prefer tabs over spaces. Some want\ntwo spaces instead of four. Some prefer semicolons and some don‚Äôt. It shouldn‚Äôt matter right?\nActually it does. If editors are autoformatting code based on user preferences, it is important\nto make sure everyone has chosen the same set of defaults. This makes it easy to tell what changed\nbetween versions ‚Äì even when different developers (with different preferences) have made changes. Prettier &  Prettier works to autoformat your code based on a shared configuration. To do this, create\na  file: You might have different preferences in your project. That‚Äôs fine, so long as all of the developers\non your website agree.  Because we‚Äôll be using TypeScript, we‚Äôll want to use TSlint. ‚ÄúLinting‚Äù is very similar to using\nprettier and in fact the two toolkits work together. To configure , create a new file called : Because we‚Äôll be using it with prettier we will also want to create a  file:  Save your progress using version control At this point we really haven‚Äôt made anything (except a lot of configuration). Even though our website isn‚Äôt even a website yet ‚Äì it still makes sense to save our work. If we make a mistake having our code saved will help us. To do this we‚Äôll use  - a version control software that lets us create commits or versions as we go. To initialize a  repository run: By default this creates an empty git repository (none of our files have been added to it). Generally, I use GitHub Desktop; however, I‚Äôll use the command line here. You can check the status of your changes and repository: You should see: Let‚Äôs get ready to create a commit by adding all of the files: Here the  means: ‚Äúeverything in the current folder‚Äù. But what are we adding it to? We are adding it to the commit stage. Let‚Äôs check the status again: You should see: We‚Äôre getting ready to add four new files to our repository. Let‚Äôs commit: This creates a commit with the message we specified. The commit acts like a save point. If we add or delete files or change something and make a mistake, we can always revert back to this point. We‚Äôll continue to commit as we make changes.  Packages & Dependencies For almost any Node project you‚Äôll find that you use a lot of packages ‚Äì you‚Äôll have far more code in packages in your  folder (where package code is stored) than your main project. Initialize your packages: Now you have a : Let‚Äôs simplify it a bit: We‚Äôll start off by installing packages for Gatsby. There are a lot of options and this list contains\nmy own opinions: This matches my setup for Gatsby; because I tend to write about code I want to support syntax-highlighting. Prism highlights code blocks in multiple languages: And better support for styled components: Additionally, we‚Äôll want to customize some parts so we‚Äôll install React: And TypeScript support: Finally, because we‚Äôre using TypeScript, we‚Äôll want to add type support for development: Our website still doesn‚Äôt work, but this is a good opportunity to create another commit; check the\nstatus: You should see: We‚Äôve added a lot of files to our folder but many of them are ignored. For example, the\n folder contains tons of files (as mentioned before), but it isn‚Äôt necessary to keep\nthose in our version control () because they can easily be reinstalled on any machine. We want\neveryone working on our project to install the same dependencies. When installing, they were\nautomatically added to the  file. The  ensures that the\ndependencies of our packages are locked to specific versions. Because of this, we‚Äôll add both of\nthese files to : And then commit: Setting up Gatsby At this point we have a solid foundation but not much to show for it. Let‚Äôs setup Gatsby so that\nwe can see some output. Gatsby is made up of a collection of packages, many of which are optional\nbased on your particular use case. Which packages you choose to use is configured in three files:  - general configuration and plugins  - build time and development generation and resolvers  - client side code bundled to run in a user‚Äôs browser  Configuration -  The configuration is broken down into two main sections:  and a list of ,\nsome of which have custom options. Here is the whole  file: Let‚Äôs break down each part.  The  section is entirely custom. You can put whatever you want in here and later use\nit in your pages (using GraphQL, which we‚Äôll cover later). The fields that I‚Äôve specified are\ncommonly used by different Gatsby sites and are often supported in different plugins and themes.  There are a list of plugins. Like the  section you have a lot of choices.  The first two plugins are actually all the same: . This allows us to\nuse files in our folder to generate our website. In this case we‚Äôve split the site content into\ntwo different folders:   This isn‚Äôt a requirement, it just helps us with organization later: You‚Äôll see these sources used when we dig into the  configuration.  Gatsby has a class of plugins called ‚Äútransformers‚Äù. These plugins take the content (from the folders\nspecified above) and transform them to be viewable as HTML (and other formats). Remark is a\ntransformer based on  which converts Markdown content to HTML. Markdown is a text format\nthat is intended to be quicker and easier to type ‚Äì while giving you a consistent output. The output can be more complex, and because of that there are a set of plugins that extend Remarkable listed as well: The extensions:  - autosizes the images so they fit better with the rest of the content  - syntax highlighting for code blocks  - allows iframes to resize correctly  - adds a link target (and ) to each header in your posts  - copies externally linked files to your project on build  - converts quotes and apostropes to smart-quotes and smart-apostrophes  and  The sharp image plugin and transformer enhance and size your images. These work together with\nbut can also be used on other images throughout your site.  Do you have a fancy ? Do you want it to work in every browser and mobile device and also\nwork as a home-screen icon and Desktop cover photo? Generating all of those and creating a manifest\nto refer to them is cumbersome‚Ä¶ unless you use :  When you deploy your website you may have a custom domain name like . However you\nmight have additional ways to get to your site such as  or\n. When Google‚Äôs search engine sees the same content at three different sites\nit thinks something is fishy. Setting a ‚Äúcanonical URL‚Äù tells Google (and others), ‚ÄúHey, if you\nfind this content via different URLs, just ignore that and use the canonical URL.‚Äù  If you want to use Google Analytics you can add it via the plugin and all of the default scripts\nwill be injected automatically:  Though we‚Äôve included some plugins that inject content into the  of each webpage, you may\nwant to include custom content, such as OpenGraph tags or Twitter cards. For this, you‚Äôll need . React generally focuses on the  of webpages, but  focuses on\nthe .  Gatbsy has good support for styled components (or CSS-in-js). Many Gatsby users use Emotion. I tend to prefer the patterns in https://www.styled-components.com/ which this plugin enables.  We‚Äôll be developing in TypeScript. This plugin adds support (including typings) to help while\ndeveloping.  Build time and development server -  When developing your website or when building, Gatsby (running on Node) relies on the setup in\n. This is where all of the pages for the website are transformed and\ngenerated. As with other parts of Gatsby there are lots of options here. For our setup, we need to\nexport two functions:   Create a file called : Let‚Äôs break it down piece by piece. We‚Äôll start off by requiring a couple of packages we‚Äôll need: Next we‚Äôll write the  function. The function starts with a GraphQL query. GraphQL is\nan API that accesses a datastore‚Äî in this case Gatsby itself. The plugins that we‚Äôve installed\ninto Gatsby provide content; specifically the  grabs all of the files\nin the specified locations and transforms them using . This provides a\nresource containing the rendered markdown. We execute the query (asyncronously), selecting the specific fields we want. Each markdown file\nwill have frontmatter: a formatted set of fields before the Markdown content starts. For example: Each one of these fields is available as items in the  connection in GraphQL. However,\nif you try to access an item via GraphQL and it is not listed in the  of every page\nyou‚Äôll get an error. For this reason we only grab the  and the  and require that\nthese are set in the  of each post. Once the GraphQL query completes we handle the result. If there is an error we immediately throw it.\nThis only happens at development or build time so throwing the error should give us immediately\nuseful feedback: In the next part of the function we setup our templates. We have two kinds of pages: Post pages Tag pages We‚Äôll construct these templates a little later. Next we‚Äôll use the data we fetched (now in the GraphQL result) and generate each page using the\n method that was passed to us: Notice that we are checking for a  and  page and passing them into the \nfield when we create the page. Each of the context fields will be converted to  we can\nuse in our  templates. The  and  allow us to build a carousel in the\nfooter of our pages. At a minimum our website should be able to display the posts we write. For my website I wanted to\nbe able to add  to posts to easily group them together. In the  I can supply a\nlist of tags: In our generator we‚Äôll loop through all of the posts and grab all of the tags. Once we have\nthem all we‚Äôll make them unique (using the  trick) so that there are no duplicates. For\neach tag we‚Äôll create a new page using our  template: With this we can create all of the pages. There is one small problem: in our GraphQL query we\nselected the  field: This field doesn‚Äôt exist by default ‚Äì we‚Äôll need to create it. We can do this by adding an \nfunction to our  file: Whenever a  is created this function will be called. If it is a  node we‚Äôll\ncreate a new field called  that we generate based on the filename.  Client side -  In general, you want to keep the client side JavaScript and stylesheets as minimal as possible.\nThis helps your pages load fast and keeps users (and Lighthouse checks) happy. Some of the plugins\nwe‚Äôve chosen will generate client-side JavaScript automatically. In fact, for our setup we only need\nto add one requirement. Create : This will inject the CSS for our syntax highlighting into the downloadable payload.  Save your progress With our configuration complete we should create another commit: You should see: Add those files: And commit them: Building the site structure: layout, pages, templates, styles and components Now that we have the configuration of the site we‚Äôll need to setup the structure. This\nincludes things like the header and footer on each page and how the pages look. We‚Äôll\ncreate the  page the  and more. Here‚Äôs the file structure: Notice that most of these files are in the  folder.  Styles For some, the design and presentation of a website is the most important aspect. There are a lot of\noptions when theming a Gatsby site (a giant inlined CSS stylesheet isn‚Äôt necessarily ideal). For\nexample, we could split our CSS into modules, rely only on locally styled components, or fully\nsupport Gatsby themes. For now we will start with something very basic: a simple CSS reset\nand an inline stylesheet.Create the file : The important pieces here are  and the generic reset. The styles that are in\nthe  function are based on Edward Tufte‚Äôs\nstyles. This provides a very minimalist theme to build on.  Layout Now that we have our basic styles we can move on to the layout. A website‚Äôs layout includes\nthe header of the page, maybe the site navigation and the site‚Äôs footer that appears on every page.\nIt is the thing that makes each page feel consistent. Create : First, we create a couple of custom styled components:   Styled components allow you to inject custom CSS at the component level and in this case are only\nused in this file. We can name them anything we want but it is common to prefix the name\nwith Styled. We then declare the  interface. Declaring interfaces and types is what gives TypeScript its\npower. Here we are saying that the component can accept an optional  property. You‚Äôll notice\nthat in the component itself we access the  prop. We get that for free (it is\ninherited) from . The  itself, is a simple React component. We use the styled components we created to build\na small site-navigation with links to our main pages, we have a main content area and a footer.\nThe only other component is the global style declaration: We inject this inside our layout (not in the ) so that changes to the style will trigger a\nre-render when using hot-module-reloading.  Head Like the  component, the  component will be used on every page. We‚Äôll use it to setup\nkeywords,  tags (like OpenGraph tags and Twitter cards) and more. Create the\nfile : The first thing we do is declare a  type. When the  component is built\nwe execute a . This is a GraphQL query that will execute and fetch results from\nGatsby similarly to the  query we saw earlier: In this query we are accessing  which we setup earlier in .\nBecause we are using TypeScript we want to declare a type for the expected result and each of\nits fields: The type and the query are very similar. If you add a field to one of them you have to add it\nto the other. The  prop of  is executed and the results are passed to the render\nfunction declared in the  prop. We‚Äôll use the default configuration for most props but allow some overrides to be passed in. For\nexample each page may choose to have a different  so we allow that to be passed in.\nThe header is rendered using a  element from .  Bio Creating a  component isn‚Äôt required. I‚Äôve created one mostly as a placeholder in case I want\nto add more components throughout the site. Create : This component is very similar to our  component. It uses a  declaration to\nexecute a GraphQL query to fetch some values from our  config. Then it renders the results.\nWe could expand this component if we wanted to, possibly allowing for an  prop to be passed\nin the event that we had multiple authors.  Pages With the basic structure like  and  in place we can start building out individual pages.\nWhen the user attempts to navigate to a particular page Gatsby will first look for a corresponding\npage created via  in . If it doesn‚Äôt find the page there it will\nnext look for a page in . For example, if a user goes to , Gatsby will try to find . For the\nroot page of the site (also known as the ) we can create a file called .\nEach page in the  folder should export a default  component. Additionally,\nit can export a  constant. The  constant is a GraphQL query that will be\nexecuted prior to rendering the component. The results from the query will be passed into the\ncomponent as a  called .  Page The  is the home page of our website. Create the file : Let‚Äôs break this down. We start of by importing the components we created earlier: Then we declare an interface for the  we expect to receive when this component is rendered.\nAs we saw earlier, pages in Gatsby are passed the result of a GraphQL query. The type of  is . We haven‚Äôt declared that type yet; it‚Äôs declared lower in\n. The  component itself is fairly straightforward. We render all of the content in the page\ninside of a  component (imported above) so that the page looks consistent with the rest\nof the site. We‚Äôve included the  and  for the same reason. The rest of the content\nis a list of articles constructed by looping through the : Notice that we link to each page using the  object. Gatsby is really great at rendering\ncontent on the client side and the  component helps handle that routing where possible. Lastly, we construct the query and the corresponding interface: Again, we could have selected any of the fields we wanted (we aren‚Äôt required to select them all).  Page The  page follows the same pattern of the . Create a file\ncalled : We haven‚Äôt added any real content to this page; it is here more as a placeholder. If you want to\nadd pages (such as a terms of service or privacy page), this file can serve as a basic example.  Page The  page of website is what the user should see when they attempt to go to a page that\ndoesn‚Äôt exist. This page is special because it isn‚Äôt rendered based on the name. Create a\nfile called :  Page When we generated all of the pages in  we created a page for each  used in\nthe frontmatter of our posts. Let‚Äôs add a page that lists all of the tags available on our site\nto make it easy to find those pages. Create a file called :  Templates We‚Äôve created all of the pages and completed the configuration but we aren‚Äôt quite done. You‚Äôll\nremember that when we generated the pages in  we referred to the  and \ntemplate files: We haven‚Äôt created those templates yet. Let‚Äôs do that now:  Template The  template is used when rendering each post for our blog. Create a file\ncalled : This page is very similar to the  and  pages. We export a default component and\nexport a  object that Gatsby will execute before rendering. In addition to passing\nthe  results from the GraphQL query, this template will also recieve a  object. The  object is actually constructed in the  function in .\nIn our case we‚Äôve passed a  and  field (optional) so that we generate a carousel\nat the bottom of each post. Another interesting part of this template is the ominously named . We saw this earlier as well. What‚Äôs it doing here? When the  plugin converts our\nMarkdown it generates HTML. Normally, if we inserted the HTML directly in our template it would\nall be escaped (for example  would become ). Not escaping HTML content is considered\ndangerous as it could introduce security vulnerabilities. In this case we know that the content\nwe are injecting was already properly escaped (by the  plugin) and we know we can\nassign it directly. The prop  is named as such to prevent you using it\non accident.  Template The  template is extremely similar to the  template. Create a file\ncalled :  Static content Static assets like images, PDF documents, videos and embedded fonts will be used throughout a\nsite. We‚Äôve only referred to one static asset in our site so far: . We linked\nto this in the manifest in . If you want to use images in your static folder elsewhere in the site you can import them directly: And then refer to returned URL: In some cases you don‚Äôt need to import the files you put in the static folder but can refer to them\ndirectly and Gatsby will automatically expand the path. For more information, see the\nstatic asset documentation.  Save your progress We‚Äôve setup the entire structure of our Gatsby site. Really, we could have committed each of the\nfiles as we added them instead of creating a giant commit. Let‚Äôs commit again: You should see: It just shows the two folders we added to the root. Add those folders: Let‚Äôs check the status again: Now you should see: We‚Äôve added everything recursively and all of the files we‚Äôve created are staged for the next commit.\nLet‚Äôs commit them: Writing posts Writing content is the most important part of your blog and where you will spend most of your\ntime. When writing a post you‚Äôll create a markdown file in  and store any images\nin . Let‚Äôs start by making the folders: Next, create a post by creating a file : Copy this Furby image and save it as :   Save your progress That‚Äôs it, we have the first post and static content: You should see: Add the  folder (and the files it contains): And commit them: Developing Now that we have content, everything should work. To get started let‚Äôs run the development server: This will prepare the package and compile all of the pages, transforming the markdown and preparing\nand executing the GraphQL: At this point you should be able to open your website in your browser: http://localhost:8000/:  The server utilizes Hot-module-reloading (HMR) so that, as you make changes, your webpage will be\nimmediately updated in the browser. This is true for themes, structure changs and content. For some changes you do need to restart the server. Generally the changes that require\na restart are related to configuration changes, for example in  or\n or if you add a new package to your . Deploying The power of Gatsby is that it can be served statically ‚Äì you don‚Äôt need a server at all. There are\nlots of options for deploying. I‚Äôve used the following: Netlify Now.sh AWS S3 GitHub Pages Since we have been keeping track of our changes in , using GitHub Pages is a natural fit (and\nfree forever). The Gatsby docs have an\nextensive set of tutorials on how to prepare and deploy your site: https://www.gatsbyjs.org/docs/deploying-and-hosting/ For me I used the  plugin and followed this tutorial: https://www.gatsbyjs.org/docs/how-gatsby-works-with-github-pages/. All of the code (and commits) are availble on GitHub: https://github.com/example-gatsby-typescript-blog/example-gatsby-typescript-blog.github.io","fields":{"slug":"/gatsby-with-typescript/"},"frontmatter":{"date":"2019-05-25T00:01:00","title":"Building a Static Gatsby-based Website with TypeScript","excerpt":"Creating a static website involves an almost infinite set of choices. I've upgraded several sites to Gatsby (including this one) finding a way to integrate TypeScript as part of the journey. Gatsby leverages React, JSX, CSS-in-JS, GraphQL and many other modern approaches to building sites."}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"tag":"javascript"}}}