{"componentChunkName":"component---src-templates-tag-tsx","path":"/tags/github/","webpackCompilationHash":"937b644821a2433c38c2","result":{"data":{"site":{"siteMetadata":{"title":"Jeff Rafter"}},"allMarkdownRemark":{"totalCount":2,"edges":[{"node":{"excerpt":"Create a repository on github If you don’t already have an account on GitHub, create one. For me, my username is\njeffrafter. You can sign up for a free account and still host your\nblog. Note: by default, your username will be part of the URL for your blog. We can change\nthat later. Next, create a new repository and name the repository . For me, I’ve\nnamed mine .  Build and push Once you’ve created the repository you need to add it as an  to your local copy: Again, using GitHub Desktop can simplify pushing code as it manages\nyour login.  Pull requests and branches  Custom domains","fields":{"slug":"/deploying-gatsby-to-github-pages/"},"frontmatter":{"date":"2019-06-01T00:01:00","title":"Deploying Gatsby to GitHub Pages","excerpt":null}}},{"node":{"excerpt":"GitHub Actions are still in beta and are changing quickly. But if you are looking to get started the possibilities are endless. This guide is mostly about pointing to documentation and exploring some fun ways to use GitHub Actions. In this post we’ll create a single repository which contains a GitHub Action - built in TypeScript - and an associated workflow. In the action we’ll respond to push events and output some logging information. Technically, you don’t need a custom script to accomplish this; you could instead build a very simple workflow which runs  commands. Using a full script will allow us to explore more capabilities of GitHub Actions. Before you read this it is important to note: starting with a template will save you a lot of time and setup. In this post, however, I am going to work through and explain all of the steps. Included in this post are some of the reasons I’ve chosen one particular setup and skipped another. When getting started with GitHub Actions it is difficult to understand how all of the pieces fit together, or why you might want to create and action for a particular task. Hopefully this post provides some helpful examples. That said, there are probably steps here that you’ve seen before, don’t care about, or just want to skip and that’s okay. In order to follow this, you’ll need a GitHub account. Additionally, you’ll need to sign up for the GitHub Actions beta. The examples will be in TypeScript. All of the code (and commits) are availble on GitHub: https://github.com/jeffrafter/example-github-action-typescript Documentation The documentation for GitHub Actions is really good (far more complete than this post) and is good to have on hand. You can learn how to build Actions, Workflows and core concepts; as well as dive deeply on using the toolkit, octokit and handling payloads. Automating your Workflow with GitHub Actions GitHub Package Toolkit Event Types & Payloads Rest API V3 octokit/rest.js Getting started First you want to create a folder for your project: We’ll be using TypeScript to build our action, which requires Node. Out of the box GitHub supports a few environments for your actions to run . There is built-in support for running actions built in JavaScript (using Node). So why did I choose to use TypeScript? It makes development a lot easier by providing compile-time checks and hints in my editor about methods and parameters (especially if you are using an editor like VSCode that has support for it). As part of our action we’ll export the TypeScript to JavaScript. Let’s setup our example to use Node. If you have multiple local projects you might run into a conflict about which Node version should be used. Node Version Manager solves this problem. To control which version of Node should be used in your project, add an  file: The file is pretty simple; just the version. I chose 10.16.3 because it matches the version that is installed in the default GitHub Action software environment. At the time you read this there may be a newer version of Node or you may chose to use an older version because your code requirements. You can check https://nodejs.org.  Ignore some things We plan to use  to keep track of our changes. As we work on our project locally, there will be a lot of files we won’t want to keep track of; we’ll want to ignore them. To do this we’ll create a new file called  . These files can be very short and specific, or they can be very long and general. We’ll use a more generic one that will work on different kinds of computers. If you are looking for an example  you can check out https://github.com/github/gitignore. For now, just copy the following: With this setup we’ll ignore  and JavaScript files in our action folders (if there was any generated locally). This is a non-standard choice but makes developing our action a little easier. By default, GitHub recommends you include the  folder as installing them per-action execution is slow (25-35 seconds). Including all of the  in your repository can lead to a lot of files and large commits which can be confusing. Additionally, if your  include platform specific dependencies which must be compiled (such as ) you will need to recompile them for the target action container anyway. Ignoring generated JavaScript in our action folders means that we have to build our TypeScript as part of our workflow. Again, this is slower and can lead to compile time errors on the server, but it saves us a few steps when developing actions.  Save your progress using version control At this point we really haven’t made anything (except a lot of configuration). Even though our website isn’t even a website yet – it still makes sense to save our work. If we make a mistake having our code saved will help us. To do this we’ll use  - a version control software that lets us create commits or versions as we go. To initialize a  repository run: By default this creates an empty git repository (none of our files have been added to it). Generally, I use GitHub Desktop; however, I’ll use the command line here. You can check the status of your changes and repository: You should see: Let’s get ready to create a commit by adding all of the files: Here the  means: “everything in the current folder”. But what are we adding it to? We are adding it to the commit stage. Let’s check the status again: You should see: We’re getting ready to add two new files to our repository. Let’s commit: This creates a commit with the message we specified. The commit acts like a save point. If we add or delete files or change something and make a mistake, we can always revert back to this point. We’ll continue to commit as we make changes.  Packages & Dependencies For almost any Node project you’ll find that you use a lot of packages – you’ll have far more code in packages in your  folder (where package code is stored) than your main project. Initialize your packages: Now you have a : Let’s simplify it a bit (you can fill out or keep fields you like here, but this is the minimum): The only scripts we need at the moment are  which will convert our TypeScript to JavaScript and  which will run our tests. While we’re working on our action we’ll need access to all of our project’s dependencies; the difference between  and  won’t matter very much. For that reason we’ll install everything as a  dependency: The  and  are the baseline for interacting with GitHub and the incoming events. When you publish an action which is meant to be used by multiple repositories and workflows, you’ll release the action with dependencies included (so they run more quickly). In that case you would use  instead of . In most other cases the code for your actions should only be used as part of your testing or development environment (not part of your production environment). We’ll want to add testing support to test our action: And TypeScript support: Finally, because we’re using TypeScript, we’ll want to add type support for development: This is a good opportunity to create another commit; check the status: You should see: We’ve added a lot of files to our folder but many of them are ignored. For example, the  folder contains tons of files (as mentioned before). We want everyone working on our project to install the same dependencies. When installing, they were automatically added to the  file. The  ensures that the dependencies of our packages are locked to specific versions. Because of this, we’ll add both of these files to : And then commit:  TypeScript We’ll also need to configure TypeScript before we can build our action. Create : By default this allows us to build all of the actions contained in our repository, adds some strict compile-time checks, and skips type checking for our dependencies. Let’s commit this file: You should see: Add it: And commit: Keep it clean Everyone has different preferences when they edit code. Some prefer tabs over spaces. Some want two spaces instead of four. Some prefer semicolons and some don’t. It shouldn’t matter right? But it does. If editors are autoformatting code based on user preferences it is important to make sure everyone has chosen the same set of defaults for that autoformatting. This makes it easy to tell what changed between versions – even when different developers (with different preferences) have made changes. For this reason we’ll setup a linter and code formatter for our code. Install eslint and prettier: Now that we have the packages we’ll need to configure them in : I won’t go into too much detail here; there are better explanations to be found. This configuration does a few things: Relies on the typescript eslint parser with the prettier plugin - I’ve found this works very well in @Code. If you were previously using  with prettier this setup should replace your old configuration. This eslint config doesn’t work perfectly for projects that contain both JavaScript and TypeScript - because of that we won’t attempt to lint JavaScript files in our project I’ve turned off the camelcase rules for properties - when writing GitHub Actions you will likely use properties from  and from the API and these will not be camelcase. The expected environment should include  and  - this will help  ignore missing declarations for things like , , , etc. If you need to ignore specific files when linting you can add them to . Because our setup doesn’t work well for JavaScript we’ll ignore all JavaScript files in : Notice that we are explicitly unignoring the  folder. This is where our source code will be kept (see next section). We have to unignore this folder explicitly because it starts with a  and is normally ignored by eslint. Add a  action to the  node in : With this in place we can run: Wait, there’s an error: We haven’t written any TypeScript to lint yet. Time to stop configuring and start writing code. Checking our  should show our changes: This makes sense; we’ve added two files and installed some new  into our packages. Let’s add everything and to the commit stage: If we check  again: Let’s commit:  Project Layout The code for GitHub Actions are generally kept in the  folder in the  folder. By default, the  folder contains metadata for the repository that can be used for automated tasks. The steps for running an action are defined in a Workflow which is usually stored in the  folder in the  folder: Repositories can contain multiple actions (or none at all); we’ll define our debug action inside a folder called . This will contain our TypeScript, generated JavaScript, tests, and the  where all of the settings for the action are kept. A repository may also have multiple workflows (or none at all); we’ll setup a workflow that runs our debug action inside .  Building the debug action Enough setup; let’s get building. Create a new file called : The code inside your action should be auto-executing. In this case we define a  method and then immediately call it right after it has been defined. In fact, you don’t even need to define a method, you could include the code for your action directly. In some cases that might be okay, but as the complexity of the action increases it would become confusing. We’ve also made our function the default export. This isn’t required but will make things easier as we move forward and test our code. There are lots of helpers built into the  package we imported. This is the simplest. Because we’re using TypeScript you may see autocomplete information in your editor:  At this point the action does nothing. Lets add some debugging: Even though this action isn’t accomplishing much, let’s write a test for it. Testing the debug action Create a new file called : We import the actions core library and the run method we just created in our debug action. In our test we create a Jest spy which allows us to verify that the  method is getting called with the correct parameters. Normally, I wouldn’t test the debug output (if it fails I don’t care too much) but this is a good foundation. In order to run this we’ll need to configure Jest. Create a new file called  in the root of your project: At this point you can run the tests. From your terminal run: You should see: It should pass. But let’s remove the debug information from the test output. Change  so that it doesn’t output the debug lines: With that change the debug output should no longer appear when we run the tests. We can run our  task to verify that our code is clean: It should succeed this time with no errors and no warnings. Let’s commit what we have. Run : Let’s add those files: Note, one of the items listed was the  folder. When we added it all of the newly added files inside of that folder were also added. Let’s check the status again: Notice that we are about to commit three files: Commit: Create the action.yml for the debug action We’ve written the code for our action and a test that tells us it is working. Unfortunately we haven’t defined how our action should be used. To do that we have to configure the action in a  file. Create : There are more configuration options available for actions but this represents the minimum amount needed to run. Specifically, it gives the action a name (which does not need to match the name of the folder) and points to the the code . Unfortunately, we don’t have a file called , we have a file called . GitHub Actions have built-in support for JavaScript and cannot run TypeScript directly. Because of this we will need to transpile our TypeScript to JavaScript before it can be run. This is done with  (the TypeScript compiler). We’ve already included a task: This will generate JavaScript files  (and ): In our setup we’ve ignored these files - they will not be included when we push our code to GitHub. This isn’t the recommended setup; GitHub suggests you include the built files for your actions to save time when running your action (and to reduce the dependencies needed by your action on the server). When developing actions it is easy to forget to build your code with each change. Because of this I’ve chosen to automatically build on execution (even though it is slower). When releasing the action it is best to include the built JavaScript.  Workflows In order to execute the  we’ve created we need to create a workflow. The  in our action defines the code to execute and the workflow defines when to execute it. Workflows should be kept in the  folder in your repository. Your repository may contain multiple workflows. Create : We’ve created a workflow that should be executed on . There are many different events that trigger worklows. By specifying  we’re saying that every time new code is pushed to our GitHub repository our workflow should be executed. In this case we’ve chosen to execute our workflow using the  environment. The steps for a workflow can point to an action that should be used or a command that should be run. Here we use both. The first step checks out our code using the  action: The  action checks out a copy of your code on the server where the workflow is running. We’ve set the fetch-depth to  indicating we only want a shallow-clone. When your action code is included in your  folder (as our  is), you must use the  action to checkout a copy of the code so that it can run. A shallow clone of the code ignores all of the history. Since our action doesn’t use any of the history this is a good speedup. The next two steps install our action dependencies and build it: Again, this is generally discouraged because it is slower and takes more resources. While developing, however it is much more simple. Finally we use our debug action: This should be enough to run our . Let’s commit: You should see: Let’s add the workflow: And commit:  Pushing to GitHub Our action and workflow are ready. All that’s left is to push to our repository on GitHub. Create a new repository. I called mine  and made it public.  Once you’ve created the repository you’ll need to click the  button make sure to setup the remote for your repository to use  instead of HTTPs:  Unfortunately you can’t push workflow changes via HTTPs as it is considered an integration. If you try you’ll see something like the following when you try to push: Setup your remote by copying the instructions on the page for : Then push: On GitHub, click on the  tab of your repository and click on the running build. When complete you should see something like:  The action ran and the build was marked as complete. But we can’t see the debug information we added. By default, GitHub will not output debug information in the action logs. To see debug output in the logs you need to add a new secret to your repository. Go to the  tab of your repository and click  on the sidebar. Then click . Set the name to  with the value  and click . Currently, there is no way to re-run an action. We’ll see the debug information when we push a new commit.  Using action input By default GitHub injects default environment variables that can be used by your action including:           (only in forks)  (only in forks) These are commonly used, but there are many instances where you want to change how an action runs based on configuration in each workflow that uses that action. Let’s add an input to our debug action that changes what the debug message says. First, define the input and default in : We’ve defined a new input called . When the action is executed the name will be will be converted to and the value will be passed in via the process environment. Environment variable names normally wouldn’t have  in them as we see in . Because of the  we need to access the values as strings. The key names in YAML syntax can vary wildly but only spaces are replaced with underscores. You could access the values directly  but using  as we have done is more future-proof. Let’s use it. Change : If we save that file and re-run our tests we’ll see a new failure: Being an amazing  is not very gratifying. The problem is that our test doesn’t know about the environment variable . Let’s set it in the test in : Setting the environment variable directly will make our test pass. After our test is complete we remove the variable to reset our state. We could do this setup and teardown with  and  callbacks: We’ve also called  which will prevent other imported modules from using a cached value. The test should still pass. What if you have a lot of inputs? It would be nice to automatically import all of the defaults. To do this we’ll need to read the  and assign all of the defaults to the environment. Install the type definitions for : And then lets expand our  and  callbacks: While this is cool, it probably adds complexity rather than reducing it. Still, it is helpful to get an idea of how the action is being executed. Our workflow can take advantage of the newly created property: We’ve added a  node to our action definition and specified the value  as our . Let’s commit and push these changes to GitHub. We should see the output this time because we turned debug output on. Check : That’s a lot of files. Add all of them: And commit: Finally let’s push to GitHub:   Action outputs Debugging output is useful but actions are much more powerful when chained together. Each action can define a set of outputs that can be used by subsequent actions. Additionally an action can set it’s status. This is especially useful for pull request workflows as the statuses can be used for automated-approval (or rejection). Suppose we want to set an output containing our message so that other steps in our workflow can use it. We can define the output in our : Here we’ve called it  and set the . In  let’s use it: We can add a test for this: We can use the output in our workflow: We’ve given our action an  node, then we refer to that  in our echo command. Let’s commit this. Run : Add the changes: And commit: And push it to GitHub: Once we’ve push this to GitHub we’ll see:  Each action can have multiple outputs.  Setting status of the action By default, if our action crashes it will fail. We can make this explicit: If the exception is handled and the program can continue we can make use of the logging functions instead:    Catching exceptions is great, but failures can happen for other reasons. For example, suppose someone chose  as the . That’s not okay: We can test this in : Get the : Add and commit in one step:  Payloads Actions are intended to respond to events: when code is pushed, when a pull request is opened or updated, when someone leaves a comment, scheduled events, etc. Every action is passed a payload. Events that trigger workflows Event Types & Payloads The easiest way to work with a payload is to try it out and log the payload to the console: Notice we added an import for the  toolkit: Then we logged the . If you push this to GitHub to run you might see: The push event documentation can be really helpful. With this information we can make our message more personal. We’ll include the name of the person pushing the code. Utilizing the information in the  node is useful but that’s only available for  actions. If you want to know who triggered the workflow for other kinds of actions you can use the  default environment variable. In this case we’ll use the value from the payload. Change : We’ll need to change our tests as well. We’ll directly set the payload in the : We could store payloads as files and use those as well, but this approach is more readable. Run : And commit: And push to GitHub: It is so encouraging! Give some love to anyone that opens an issue Writing output to the logs is fine. Setting the completion and failed status of the action is also cool. Automating your workflow using the API is the best. Actions can automatically create issues, pull request reviews, commits and more. To demonstrate, let’s create a new action. When a friendly contributor opens an issue in our repository our GitHub Action will thank them and add a reaction to their issue. We’ll add the following:  Using the API Every action that runs has access to a  environment variable that can be used to interact with the API. The token has read and write (but not admin) repository app permissions by default. Virtual Environments documentation To use the  you must configure the environment of your action when it is referenced in the workflow. Remember actions can be used by many workflows in many repositories and granting access should be protected.\nThe workflow for our thanks action will be triggered when an issue is opened. Create : Each step that makes use of the  must include: We’ll also need a new  for our thanks action. Create : Notice that we’ve specified an input with a default message. If we wanted we could specify different messages in our workflows that use this action. With the environment set we’re ready to create : Let’s break this down. Using  events to trigger our workflow allows us to respond to newly opened issues. However, every change to an issue will trigger our workflow: when an issue is opened, closed, edited, assigned, etc. Because of this we want to make sure our action is only making changes when the issue is opened: We’ll need to access the  in the payload: At this point we grab the token that was injected into the environement from our workflow: We use the token to create a new GitHub client: The client that is created is actually an octokit/rest.js API client. The  client has full access to the Rest API V3. There is great documentation available: octokit/rest.js @actions/github Rest API V3 Once you have a  client you’ll usually want to work with the current repository. There are a set of automatically included environment variables to make this easier. For example, the  environment variable contains the repository name with owner () like : At this point we’re ready to create a comment replying to the opened issue. We grab the  from the action input. Then we create the comment via the  client: Calling the API requires HTTP interactions which are not instant. Because working with the API involves asynchronous callbacks, most API calls will return a  containing a response object (with , , and ). if If you don’t care about the result, you can ignore the response and continue on. If you need to use the response, however, you’ll need to use  to let the  request complete. Here we are logging out the comment URL from the response so we need to use  to make sure the response is complete. We also want to add a reaction to the issue: Again we use  to wait for the response from the API call. Testing API interactions Whem working with the API it is important to configure your tests so they don’t actually interact with GitHub’s API. In general, you don’t want your tests to call the API directly; they might start creating real issues in your repositories or use up your rate limits. Instead you should be mocking all of the external calls from your test suite. This will also make your tests run faster. It is common to use  to mock external requests and responses. Install it along with the supporting types: There are great examples available in the  repository on mocking the octokit client and in the  README. By default, we want to disable all external calls from our test suite. To do this add the following to the top of : Now if one of our tests attempts use the API nock will prevent it and fail the test with an error like: Let’s create a new test. Create : We start off by setting up a fake payload. The real payload (when GitHub runs our action) will be much bigger and contain more information; however we’ve made our example payload in the test as small as possible to keep things focused. The test that we’ve created does nothing more than attempt to run our action. We’re not verifying any output or debug information (though we could). Instead we are validating that the API endpoints are hit with specific parameters. If these mocked API requests don’t occur (as we have specified them), the test will fail: Notice that we are also specifying the response body. This allows our action code to utilize the response exactly as it would from a real API interaction. Again, when developing your action you might use  to see what the actual output looks like before setting up your tests. Some might argue that this level of mocking for your tests is too much. We’re faking the input, faking the API endpint and faking the responses. So what is this test even doing? The approach here is one of efficiency. I’m trusting that the GitHub API works and that the way I’ve set it up won’t change. With those assumptions set in my tests, I’m free to change the code that leads up to those interactions in any way I see fit. I’ve mocked the edges, but my actions code still must do the right thing. It’s a trade-off but once you’ve established how the edges of your code work it allows much faster iteration. If we run the tests with  we see: At this point the action works. Let’s check : Let’s add all of those: And commit: And push to GitHub: When we pushed, our  still executed, but not our new . In order to trigger that we have to open a new issue. Open a new issue with any message and then watch the action execute. You should see something like:  It works! But… it doesn’t feel very personal to have a bot replying to collaborators. It would feel much better if a human were replying. Unfortunately all of the interactions with the repository are on behalf of the GitHub Actions bot because we are using the . In order to act on behalf of another user we’ll need to use a different token. o do this, we’ll generate a personal access token. To create a token, go to your token settings in GitHub (click on  in the user drop-down menu, then  in the sidebar, then click on ). Then click the  button.  Make sure you’ve checked the  box to grant repository access permissions to the token. Copy the token (note, this is just an example and this token has been revoked so you can’t use it):  Next, we’ll need to add a new secret to our repository. Open the setings for your repository and click  in the sidebar. Click  and set the name to  and paste the copied personal access token into the . Click .  Now that we’ve created a new secret containing our token we need to use it. To use it, we’ll need to modify our workflow. Right now the  node in our workflow specifies the . Let’s add an entry for the : This will inject the secret into our environment. We’ll need to modify  to use it. Currently we have: Let’s change that to: That’s it. At this point  should still pass and  should have no warnings or errors. Let’s check the : And commit: Push it to GitHub: Open a new example issue and you should see your user account reply:  Thanks Lots of folks @GitHub helped review and solve some of the issues I came across while writing this post. Special shout-outs go to @jasonetco, @mscoutermarsh, and mikekavouras. Also, special thanks to the docs team and the octokit/rest.js team who make great things.","fields":{"slug":"/working-with-github-actions/"},"frontmatter":{"date":"2019-09-13T00:01:00","title":"Working with GitHub Actions","excerpt":"GitHub Actions are still in beta and are changing quickly. But if you are looking to get started the possibilities are endless."}}}]}},"pageContext":{"isCreatedByStatefulCreatePages":false,"tag":"github"}}}